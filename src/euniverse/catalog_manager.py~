import os
import re
from astropy.table import Table
from PyQt5.QtWidgets import QGraphicsEllipseItem
from PyQt5.QtGui import QPen, QColor
from PyQt5.QtCore import QRectF
from astropy.coordinates import SkyCoord
import astropy.units as u
import numpy as np

# Define NA as a recognized unit so the parser doesn't complain
u.def_unit('NA', u.dimensionless_unscaled, register_to_subclass=True)

class CatalogManager:
    def __init__(self, tileID, wcs, search_dir=".", image_viewer=None):
        """
        Initialize CatalogManager with a tile ID, WCS, and optionally the image_viewer
        
        Args:
            tileID (str): Tile identifier (e.g., 'TILE123456789').
            wcs (WCSConverter): WCS object for coordinate conversion.
            search_dir (str): Directory to search for FITS table.
            image_viewer (ImageViewer, optional): Reference to the ImageViewer instance.
       """
        self.tileID = tileID
        self.wcs = wcs
        self.search_dir = search_dir
        self.catalog = None
        self.MER_items = []
        self.selected_MER_items = []
        self.image_viewer = image_viewer
        self.catalog_name = None
        self.catalog_path = None
        self.has_magnitudes = False
        self.load_catalog()
        self.numsources = self.get_catalog_row_count()
        
    def load_catalog(self):
        """
        Search for and load the FITS table with the matching tile_id and 'EUC_MER_FINAL-CAT' in the filename.
        """
        try:
            for filename in os.listdir(self.search_dir):
                if (
                        self.tileID in filename and
                        'EUC_MER_FINAL-CAT' in filename and
                        filename.lower().endswith(('.fits'))
                ):
                    if filename.endswith(".fits"):
                        self.catalog_name = filename[:-5]+"\n"
                    filepath = os.path.join(self.search_dir, filename)
                    self.catalog = Table.read(filepath, format='fits')
                    self.catalog_path = self.search_dir

                    self.delete_empty_columns()
                    self.compute_magnitudes()
                    
                    if self.image_viewer:
                        self.image_viewer.update_status(f"Loaded MER catalog: {filename}", 3000)
                    return
                
            # If loop completes without finding a match
            raise FileNotFoundError(f"MER catalog not present for {self.tileID} in {self.search_dir}. Catalog overlay not possible.")
    
        except FileNotFoundError as e:
#            print(f"Error loading MER catalog: {e}")
            if self.image_viewer:
                self.image_viewer.update_status(str(e), 10000)
                print(f"{e}")
            self.catalog = None
        except Exception as e:
#            print(f"Error loading MER catalog: {e}")
            if self.image_viewer:
                self.image_viewer.update_status(f"Error loading catalog: {e}", 10000)
                print(f"Error loading MER catalog: {e}")
            self.catalog = None

    def get_catalog_row_count(self):
        """
        Returns the number of rows in the loaded catalog.  Returns 0 if no catalog is loaded.
        """
        if self.catalog is not None:
            return len(self.catalog)
        else:
            return 0

    def get_non_empty_columns(self):
        """Return list of non-empty column names in the catalog."""
        if not self.catalog:
            return []
        return [col for col in self.catalog.colnames if not all(self.catalog[col].mask)]

    def get_all_column_names(self):
        """Return a list of all column names in the catalog."""
        if self.catalog is not None:
            return self.catalog.colnames
        else:
            return []

    def delete_empty_columns(self):
        columns_to_remove = []
        for col_name in self.catalog.colnames:
            column_data = self.catalog[col_name]
            # Check if the column is entirely masked (for Astropy Table MaskedColumn)
            if hasattr(column_data, 'mask') and np.all(column_data.mask):
                columns_to_remove.append(col_name)
            # Check if all values are NaN or None (for regular numpy arrays or lists)
            elif isinstance(column_data, np.ndarray) and np.all(np.isnan(column_data)):
                columns_to_remove.append(col_name)
            elif all(item is None for item in column_data):
                 columns_to_remove.append(col_name)
        if columns_to_remove:
            self.catalog.remove_columns(columns_to_remove)
            if self.image_viewer:
                self.image_viewer.update_status(f"Removed {len(columns_to_remove)} empty columns.", 2000)

        
    def compute_magnitudes(self):
        # leave if done already
        if self.has_magnitudes:
            return
        
        # Compute AB magnitudes for FLUX columns in microJansky
        for col in self.catalog.colnames:
            if col.startswith('FLUX'):
                new_col_name = col.replace('FLUX', 'MAG')
                log_input = 1e-6 * self.catalog[col].data
                # Calculate mag only for positive fluxes, assign 99 otherwise
                mask = log_input > 0
                # For non-positive values, this part will be ignored by np.where
                good_mag = -2.5 * np.log10(log_input[mask]) + 8.90
                # Initialize an array of the same shape as log_input, filled with 99
                mag = np.full_like(log_input, 99.0, dtype=np.float32)
                # Assign the calculated magnitudes only where mask is True
                mag[mask] = good_mag
                self.catalog[new_col_name] = mag

        self.has_magnitudes = True


    def make_ellipse(self, x, y, a, b, pa, color, width, ID):
        ellipse = QGraphicsEllipseItem(QRectF(x-a, y-b, 2*a, 2*b))
        ellipse.setPen(QPen(color, width))
        ellipse.setTransformOriginPoint(x,y)
        ellipse.setRotation(90-pa)  # Correct translation of position angle to image display
        ellipse.setData(0, ID)  # Store OBJECT_ID
        return ellipse
        
    def get_MER(self, image_height):
        """
        Extract source parameters from the catalog and create MER ellipse items.
        
        Args:
        image_height (int): Image height in pixels for TIFF y-coordinate flip.
        
        Returns:
        list: List of QGraphicsEllipseItem objects.
        """
        if not self.catalog:
            print("No MER catalog available for plotting")
            return []
        
        if not self.wcs:
            print("No WCS; cannot overlay MER catalog")
            return []

        self.MER_items = []
        try:
            # Extract required columns
            required_columns = [
                'OBJECT_ID', 'RIGHT_ASCENSION', 'DECLINATION',
                'SEMIMAJOR_AXIS', 'POSITION_ANGLE', 'ELLIPTICITY'
            ]
            for col in required_columns:
                if col not in self.catalog.colnames:
                    raise KeyError(f"Column {col} missing in FITS table")
                
            # Extract RA and Dec
            ra = self.catalog['RIGHT_ASCENSION'].data
            dec = self.catalog['DECLINATION'].data
            a = self.catalog['SEMIMAJOR_AXIS'].data
            e = self.catalog['ELLIPTICITY'].data
            pa = self.catalog['POSITION_ANGLE'].data
            object_ids = self.catalog['OBJECT_ID'].data
            
            # Ensure RA and Dec are numeric arrays
            ra = np.array(ra, dtype=float)
            dec = np.array(dec, dtype=float)
            
            # Create SkyCoord for all coordinates
            sky_coords = SkyCoord(ra=ra, dec=dec, unit='deg', frame='icrs')

            # Convert RA/Dec to pixel coordinates
            x, y = self.wcs.world_to_pixel(sky_coords)
            y = image_height - y  # Flip y-axis to match image coordinates

            # Compute semi-minor axis: B = A * (1 - E)
            a = 3 * a # Rescale to make SourceExtractor shape parameters approximate the true extent
            b = a * (1 - e)
            # Create MER ellipse items
            for i in range(len(x)):
                ellipse = self.make_ellipse(x[i], y[i], a[i], b[i], pa[i], QColor(255, 0, 0), 1, object_ids[i])
                self.MER_items.append(ellipse)
                
            if self.image_viewer:
                self.image_viewer.update_status(f"Retrieved {len(self.MER_items)} sources from MER catalog")

        except Exception as e:
            if self.image_viewer:
                self.image_viewer.update_status(f"Error processing MER cat: {e}",5000)
            print(f"Error processing MER cat: {e}")

        
    def handle_selected_objects(self, object_ids):
        """
        Slot to handle lasso-selected OBJECT_IDs from PlotDialog.
        Plots yellow ellipses for selected objects and centers the view.
        
        Args:
            object_ids (list): List of selected OBJECT_IDs.
        """

        # Get image_height from image_viewer.original_image
        try:
            image_height = self.image_viewer.original_image.shape[0]
        except AttributeError:
            print("Error: original_image not found in image_viewer or invalid shape")
            if self.image_viewer:
                self.image_viewer.update_status("Please load an image first", 5000)
            return

        # Get selected MER ellipses
        self.get_selected_MER(object_ids, image_height)

        # Add items to the QGraphicsScene and store them
        self.image_viewer.show_selected_MER()

                
    def get_selected_MER(self, selected_object_ids, image_height):
        """
        Extract source parameters and create yellow MER ellipse items for selected OBJECT_IDs.
        Centers the QGraphicsView on the first selected object.
        
        Args:
            selected_object_ids (list): List of OBJECT_IDs to plot.
            image_height (int): Image height in pixels for TIFF y-coordinate flip.
        
        Returns:
            list: List of QGraphicsEllipseItem objects for selected objects.
        """
        if not self.catalog:
            print("No MER catalog available for plotting")
            if self.image_viewer:
                self.image_viewer.update_status("No MER catalog available", 5000)
            return []
        
        if not self.wcs:
            print("No WCS; cannot overlay MER catalog")
            if self.image_viewer:
                self.image_viewer.update_status("No WCS available", 5000)
            return []
        
        if not selected_object_ids:
            print("No selected OBJECT_IDs provided")
            if self.image_viewer:
                self.image_viewer.update_status("No objects selected", 2000)
            return []

        # Clear previous selection
        self.clear_selected_MER()
        try:
            # Extract required columns
            required_columns = [
                'OBJECT_ID', 'RIGHT_ASCENSION', 'DECLINATION',
                'SEMIMAJOR_AXIS', 'POSITION_ANGLE', 'ELLIPTICITY'
            ]
            for col in required_columns:
                if col not in self.catalog.colnames:
                    raise KeyError(f"Column {col} missing in FITS table")

            # Filter catalog for selected OBJECT_IDs
            mask = np.isin(self.catalog['OBJECT_ID'].data, selected_object_ids)
            if not np.any(mask):
                print("No matching OBJECT_IDs found in catalog")
                if self.image_viewer:
                    self.image_viewer.update_status("No matching objects found", 2000)
                return []
            selected_catalog = self.catalog[mask]

            # Extract RA, Dec, and other parameters
            ra = np.array(selected_catalog['RIGHT_ASCENSION'].data, dtype=float)
            dec = np.array(selected_catalog['DECLINATION'].data, dtype=float)
            a = selected_catalog['SEMIMAJOR_AXIS'].data
            e = selected_catalog['ELLIPTICITY'].data
            pa = selected_catalog['POSITION_ANGLE'].data
            object_ids = selected_catalog['OBJECT_ID'].data

            # Create SkyCoord for coordinates
            sky_coords = SkyCoord(ra=ra, dec=dec, unit='deg', frame='icrs')

            # Convert RA/Dec to pixel coordinates
            x, y = self.wcs.world_to_pixel(sky_coords)
            y = image_height - y  # Flip y-axis

            # Compute semi-minor axis: B = A * (1 - E)
            a = 3 * a  # Rescale as in get_MER
            b = a * (1 - e)

            # Create yellow ellipse items
            for i in range(len(x)):
                ellipse = self.make_ellipse(x[i], y[i], a[i], b[i], pa[i], QColor(255, 255, 0), 1, object_ids[i])
                self.selected_MER_items.append(ellipse)

            # Center QGraphicsView on the first selected object
            if len(x) > 0:
                first_x, first_y = x[0], y[0]
                self.image_viewer.centerOn(first_x, first_y)
                self.image_viewer.update_status(f"Plotted {len(x)} selected sources in yellow, centered on OBJECT_ID {object_ids[0]}", 3000)


        except Exception as e:
            print(f"Error processing selected MER catalog: {e}")
            if self.image_viewer:
                self.image_viewer.update_status(f"Error processing selected MER: {e}", 5000)

    # Currently unused
    def clear_MER(self):
        """
        Clear the list of MER items.
        """
        self.image_viewer.hide_MER()
        self.MER_items = []

    def clear_selected_MER(self):
        """
        Clear the list of selected MER items.
        """
        self.image_viewer.hide_selected_MER()
        self.selected_MER_items = []
